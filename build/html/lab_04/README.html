
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>04 - Cassandra &#8212; IoT Labs  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="03 - MQTT" href="../lab_03/README.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section class="tex2jax_ignore mathjax_ignore" id="cassandra">
<h1>04 - Cassandra<a class="headerlink" href="#cassandra" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this lab we are going to have a closer look at Cassandra, a database engine which was designed for high availability and scalability. To achieve these goals the databases on the cassandra engine are distributed on any desired nodes. The Cassandra engine focuses upon a decentralized architecture. We build a simple cluster, create a table and modify data by using the Cassandra Query Language (CQL).</p>
<p>Further on we will have a quick look at the <em>cqlsh</em>, establish a connection to our Cassandra cluster and run simple read and write queries against the Cassandra database. We then examine an application architecture with whose we are able to handle request storms, in our case from an MQTT broker and write down data to a replicated database like Cassandra.</p>
</section>
<section id="prerequisites">
<h2>Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Hardware with following key specifications</p>
<ul class="simple">
<li><p>&gt;= 8 GB of RAM recommended</p></li>
<li><p>4 Cores / 8 CPUs (Hyperthreading) recommended</p></li>
<li><p>Virtualization supported by the CPU (VT-x/AMD-V) would be a big plus.</p></li>
<li><p>At least 32 GiB of free disk space to place the virtual disk image of the guest machine.</p></li>
</ul>
</li>
<li><p>Virtualization environment (VMWare Player / VirtualBox)<br />
(Lab was developed using VirtualBox <a class="reference external" href="https://www.virtualbox.org/">https://www.virtualbox.org/</a>)</p></li>
<li><p>Virtual harddisk image (hostname: iot-lab-vsrvr) provided by this lab.</p>
<ul class="simple">
<li><p>Get it from inside of the lab subnet (net: 172.16.32.0/24)</p></li>
</ul>
</li>
<li><p>At least 1 Raspberry Pi to submit data to a MQTT broker</p>
<ul class="simple">
<li><p>raspbian operating system</p></li>
</ul>
</li>
</ol>
</section>
<section id="getting-started">
<h2>Getting started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<section id="environment-overview">
<h3>Environment overview<a class="headerlink" href="#environment-overview" title="Permalink to this headline">¶</a></h3>
<p><img alt="infrastructure_cassandra_nodes.png" src="../_images/infrastructure_cassandra_nodes.png" /></p>
</section>
<section id="alternate-environment-setup">
<h3>Alternate environment setup<a class="headerlink" href="#alternate-environment-setup" title="Permalink to this headline">¶</a></h3>
<p>If you are outside of the IoT subnet (172.16.32.0/24), and dont’t have access to the lab broker, you can start the mosquitto broker on the <strong>iot-lab-vsrvr</strong> by invoking the command: <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">service</span> <span class="pre">mosquitto</span> <span class="pre">start</span></code>. Remember that in this case you have to change the virtual machine’s network adapter to a “Bridged Adapter”, so that &lt;your_own_laptop&gt;, the <strong>iot-lab-vsrvr</strong> and your <strong>Raspberry Pi’s</strong> reside in the same subnet.</p>
</section>
</section>
<section id="setting-up-the-guest-machine-iot-lab-vsrvr">
<h2>Setting up the guest machine “iot-lab-vsrvr”<a class="headerlink" href="#setting-up-the-guest-machine-iot-lab-vsrvr" title="Permalink to this headline">¶</a></h2>
<p>Get the virtual hard disk image from inside of the lab subnet (172.16.32.0/24) via:</p>
<p><a class="reference external" href="ftp://jupiter.lab.iot/shared/IoT/p4">ftp://jupiter.lab.iot/shared/IoT/p4</a></p>
<p>FTP-User: <strong>iotro</strong></p>
<p>FTP-Password: <strong>iotro</strong></p>
<p>You can download the image from outside the ZHAW LAN as well. It is also hosted on Switch Drive and is accessible through the following URL:
<a class="reference external" href="https://drive.switch.ch/index.php/s/Vqis1eTZ1CS8f2s">https://drive.switch.ch/index.php/s/Vqis1eTZ1CS8f2s</a></p>
<p>Uncompress the virtual harddisk image … this may take a little, time for a coffee break.</p>
<p>Set up a virtual machine on your virtualization environment and use the virtual disk image, you just downloaded (it is a <em>32 bit debian system</em>). Recommended are the following settings:</p>
<ul class="simple">
<li><p>4 GiB of RAM</p></li>
<li><p>2 or 4 CPUs (<strong>Just one single core will not work</strong>)</p></li>
<li><p>Enable PAE/NX (on VirtualBox)</p></li>
<li><p>Enable VT-x/AMD-V</p></li>
<li><p>Network adapter in NAT mode<br />
(or a bridged adpter if you use the alternate environment setup)</p></li>
</ul>
<p>Start the virtual machine. On the virtual machine with the hostname <em>iot-lab-vsrvr</em> you can operate with these credentials:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Username</p></th>
<th class="head"><p>Password</p></th>
<th class="head"><p>is sudoer?</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>iotusr</p></td>
<td><p>iotlab</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p>root</p></td>
<td><p>iotlab</p></td>
<td><p>yes (root user)</p></td>
</tr>
</tbody>
</table>
</section>
<hr class="docutils" />
<section id="apache-cassandra">
<h2>Apache Cassandra<a class="headerlink" href="#apache-cassandra" title="Permalink to this headline">¶</a></h2>
<p>In this section we are going to set up a Cassandra cluster with a very trivial configuration, on two virtual nodes which run on the <em>iot-lab-vsrvr</em>, <em>cassandra-node-0</em> and <em>cassandra-node-1</em>. Later on we use the <code class="docutils literal notranslate"><span class="pre">cqlsh</span></code> to get in touch with the CQL language and run simple queries against the distributed database.</p>
<section id="id1">
<h3>Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<section id="architecture-overview">
<h4>Architecture Overview<a class="headerlink" href="#architecture-overview" title="Permalink to this headline">¶</a></h4>
<p>Some key features of a Cassandra database system are listed below:</p>
<ul class="simple">
<li><p>Cassandra was designed with the understanding that system/hardware failures can and do occur</p></li>
<li><p>Peer-to-peer, distributed system</p></li>
<li><p><strong>All nodes the same (No master-slave architecture or anything similar)</strong></p></li>
<li><p>Data partitioned among all nodes in the cluster</p></li>
<li><p>Custom data replication to ensure fault tolerance</p></li>
<li><p>Read-/Write-anywhere design</p></li>
<li><p><strong>Each node communicates with each other through the Gossip protocol, which exchanges information  across the cluster every second</strong></p></li>
<li><p>A commit log is used on each node to capture write activity. Data durability is assured.</p></li>
<li><p>Data also written to an in-memory structure (memtable) and then to disk once the memory structure is full (an SStable)</p></li>
<li><p>A keyspace is akin to a database in the RDBMS table but is more flexible/dynamic</p></li>
<li><p>6A row in a column family is indexed by its key. Other columns may be indexed as well.</p></li>
</ul>
<p>Source: <a class="reference external" href="http://www.slideshare.net/DataStax/an-overview-of-apache-cassandra">http://www.slideshare.net/DataStax/an-overview-of-apache-cassandra</a></p>
<p>In our installation we are going to use a basic setup and only two nodes to replicate our databases:</p>
<p>Which means that we can run queries against arbitrary nodes in the Cassandra cluster and all the changes are replicated all over the cluster. As you can see, Cassandra builds a ring structure including all its available nodes.</p>
</section>
<section id="snitches">
<h4>Snitches<a class="headerlink" href="#snitches" title="Permalink to this headline">¶</a></h4>
<p>A snitch determines which data centers and racks are written to and read from. Snitches inform Cassandra about the network topology so that requests are routed efficiently and allows Cassandra to distribute replicas by grouping machines into data centers and racks. All nodes must have exactly the same snitch configuration. Cassandra does its best not to have more than one replica on the same rack (which is not necessarily a physical location).</p>
<p>Note: If you change the snitch after data is inserted into the cluster, you must run a full repair, since the snitch affects where replicas are placed.</p>
<p>Snitch types Cassandra supports:</p>
<ul class="simple">
<li><p><strong>Dynamic snitching</strong><br />
Monitors the performance of reads from the various replicas and chooses the best replica based on this history.</p></li>
<li><p><strong>SimpleSnitch</strong><br />
The SimpleSnitch is used only for single-data center deployments.</p></li>
<li><p><strong>RackInferringSnitch</strong><br />
The RackInferringSnitch determines the location of nodes by rack and data center.</p></li>
<li><p><strong>PropertyFileSnitch</strong><br />
Determines the location of nodes by rack and data center.</p></li>
<li><p><strong>GossipingPropertyFileSnitch</strong><br />
Automatically updates all nodes using gossip when adding new nodes and is recommended for production.</p></li>
<li><p><strong>Ec2Snitch</strong><br />
Use with Amazon EC2 in a single region.</p></li>
<li><p><strong>EC2MultiRegionSnitch</strong><br />
Use this snitch for deployments on Amazon EC2 where the cluster spans multiple regions.</p></li>
</ul>
<p>Source: <a class="reference external" href="http://docs.datastax.com/en/cassandra/1.2/cassandra/architecture/architectureSnitchesAbout_c.html">http://docs.datastax.com/en/cassandra/1.2/cassandra/architecture/architectureSnitchesAbout_c.html</a></p>
<p>In our simple architecture with only 2 nodes in 1 “datacenter” we use a SimpleSnitch as endpoint snitch, which is sufficient for this purpose. In the configuration file this is the default and doesn’t have to be changed.</p>
<p>If you want to go in deep an explore all the configuration possibilites and setup concepts of a Cassandra cluster e.g. a distributed cluster over many datacenters, etc. you can do so by consulting the Datastax Documentations: <a class="reference external" href="http://docs.datastax.com/en/index.html">http://docs.datastax.com/en/index.html</a></p>
</section>
</section>
<section id="installation">
<h3>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h3>
<p>To install the cassandra cluster we operate as the user iotusr on the “iot-lab-vsrvr”.</p>
<p>As you have started your <em>iot-lab-vsrvr</em> in a previous section, one can open a terminal and cd in the labs directory: <code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">/home/iotusr/IoT/p4</span></code></p>
<p>We first have to create a virtual switch in NAT mode to build our own subnet which has also an uplink to the outside world.</p>
<p>To get the environment on the <em>iot-lab-vsrvr</em> like pictured above invoke the bash script:</p>
<p><code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">./start_cassandra_env.bash</span></code></p>
<p>To control the virtual cassandra nodes, you can use the virsh tool and the following commands:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Command</p></th>
<th class="head"><p>Descripütion</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>sudo virsh list</strong></p></td>
<td><p>list machines and their state</p></td>
</tr>
<tr class="row-odd"><td><p><strong>sudo virsh create &lt;machine_xml_file&gt;</strong></p></td>
<td><p>create and start a virtual machine specified in &lt;machine_xml_file&gt;</p></td>
</tr>
<tr class="row-even"><td><p><strong>sudo virsh reboot <machine-id></strong></p></td>
<td><p>reboot specified machine by its machine id</p></td>
</tr>
<tr class="row-odd"><td><p><strong>sudo virsh shutdown <machine-id></strong></p></td>
<td><p>shutdown specified machine by its machine id</p></td>
</tr>
</tbody>
</table>
<p>visrsh provides many more options. For a verbose description of all of them, consult the manual pages:  <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">virsh</span></code></p>
<p>Now that the Cassandra nodes are running try to login from the <em>iot-lab-vsrvr</em>:</p>
<p>Credentials:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Hostname</p></th>
<th class="head"><p>IP address</p></th>
<th class="head"><p>Username</p></th>
<th class="head"><p>Password</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cassandra-node-0</p></td>
<td><p>192.168.122.10</p></td>
<td><p>root</p></td>
<td><p>iotlab</p></td>
</tr>
<tr class="row-odd"><td><p>cassandra-node-1</p></td>
<td><p>192.168.122.20</p></td>
<td><p>root</p></td>
<td><p>iotlab</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">ssh</span> <span class="pre">&lt;Username&gt;&#64;&lt;IP</span> <span class="pre">address&gt;</span></code></p>
<p>Due to simplicity we always act as root user on the Cassandra database nodes in this lab. Never do this in a productive environment. For example you can create a specific application user.</p>
<p>On each Cassandra node the Cassandra application package is already downloaded. To build a simple cluster with our two nodes, we have to define a seed node and another <em>normal</em> node.</p>
<p>Let’s start with the configuration of the seed node:</p>
<p>Login via ssh to the Cassandra node with the IP address 192.168.122.10, this is our seed node:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /usr/local/bin
tar xvf apache-cassandra-2.1.11-bin.tar.gz
<span class="nb">cd</span> apache-cassandra-2.1.11/conf
vim cassandra.yaml
</pre></div>
</div>
<p>Now we can edit the configuration file:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>starting characters of line</p></th>
<th class="head"><p>actual value</p></th>
<th class="head"><p>new value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>cluster_name</p></td>
<td><p>‘Test Cluster’</p></td>
<td><p>‘iotLabCassandraCluster’</p></td>
</tr>
<tr class="row-odd"><td><p>- seeds</p></td>
<td><p>“127.0.0.1”</p></td>
<td><p>“192.168.122.10”</p></td>
</tr>
<tr class="row-even"><td><p>listen_address</p></td>
<td><p>localhost</p></td>
<td><p>192.168.122.10</p></td>
</tr>
<tr class="row-odd"><td><p>rpc_address</p></td>
<td><p>localhost</p></td>
<td><p>192.168.122.10</p></td>
</tr>
</tbody>
</table>
<p>Where:</p>
<ul class="simple">
<li><p>rpc_address is the address on which Cassandra listens to the client calls like CQL queries.</p></li>
<li><p>listen_address is the address on which Cassandra listens to the other Cassandra nodes in the cluster.</p></li>
<li></li>
</ul>
<p>In productive environments it is an optimization to have different ineterfaces/subnets for syncronizing the cassandra nodes and process CQL queries from applications or db admins.</p>
<p>Now let things roll:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ..
bin/cassandra
</pre></div>
</div>
<p>The node should now start up. This may take a while. Wait until you see a message on your console like:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>INFO  <span class="m">19</span>:01:40 No gossip backlog<span class="p">;</span> proceeding
</pre></div>
</div>
<p>The seed node is now started. Now open another terminal on <em>iot-lab-vsrv</em> and repeat the whole configuration procedure for the other Cassandra node with the IP address: 192.168.122.20. Keep in mind to use the correct IP addresses and specify the right seed node (192.168.122.10).</p>
<p>If everything worked flawlessly, open two other terminals on “iot-lab-vsrv” and connect to the two cassandra nodes as root via ssh and type:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>/usr/local/bin/apache-cassandra-2.1.11/bin/nodetool status
</pre></div>
</div>
<p>A sample output would be:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Datacenter: <span class="nv">datacenter1</span>
<span class="o">=======================</span>
<span class="nv">Status</span><span class="o">=</span>Up/Down
<span class="p">|</span>/ <span class="nv">State</span><span class="o">=</span>Normal/Leaving/Joining/Moving
--  Address         Load       Tokens  Owns <span class="o">(</span>effective<span class="o">)</span>  Host ID                               Rack
UN  <span class="m">192</span>.168.122.10  <span class="m">51</span>.65 KB   <span class="m">256</span>     <span class="m">100</span>.0%            52ae0bff-9b6a-4020-b78a-e6175f6aa8f8  rack1
UN  <span class="m">192</span>.168.122.20  <span class="m">66</span>.06 KB   <span class="m">256</span>     <span class="m">100</span>.0%            f78bafe4-558e-473e-8137-2165337dda39  rack1
</pre></div>
</div>
<p>UN stands for <strong>U</strong>p <strong>N</strong>ormal which means your node runs as expected and no serious errors were reported during the startup.</p>
</section>
<section id="get-in-touch-with-the-cqlsh-and-cql">
<h3>Get in touch with the cqlsh and CQL<a class="headerlink" href="#get-in-touch-with-the-cqlsh-and-cql" title="Permalink to this headline">¶</a></h3>
<p>To run database queries we use the CQL shell (cqlsh), which comes with the Cassandra installation package. The sample queries we run from the host <em>iot-lab-vsrv</em>.</p>
<p>Open a terminal on the <em>iot-lab-vsrv</em> and make sure that you are in your <code class="docutils literal notranslate"><span class="pre">~</span></code> directory (<code class="docutils literal notranslate"><span class="pre">/home/iotusr</span></code>).</p>
<p>Start the cqlsh by typing: <code class="docutils literal notranslate"><span class="pre">./cqlsh</span> <span class="pre">-C</span> <span class="pre">192.168.122.[12]0</span> <span class="pre">9042</span></code></p>
<p>It doesn’t matter if you connect to node 0 or node 1.</p>
<p>(To get more information about the cqlsh, type <code class="docutils literal notranslate"><span class="pre">./cqlsh</span> <span class="pre">-help</span></code>)</p>
<p>As you may have noticed, we connected to the database without any authentication. Again, <strong>NEVER EVER</strong> do this in productive environments.</p>
<p>If you want to harden your Cassandra cluster by enabling and configuring security settings / adding users / alter passwords / … you may find a good entry point to this topic at: <a class="reference external" href="http://www.datastax.com/dev/blog/a-quick-tour-of-internal-authentication-and-authorization-security-in-datastax-enterprise-and-apache-cassandra">http://www.datastax.com/dev/blog/a-quick-tour-of-internal-authentication-and-authorization-security-in-datastax-enterprise-and-apache-cassandra</a></p>
<p>Now lets run a few simple queries against our Cassandra cluster from the cqlsh. In most cases we call pre-written scripts. These are located in the <code class="docutils literal notranslate"><span class="pre">~</span></code> directory of the user <em>iotusr</em> on the <em>iot-lab-vsrvr</em>.</p>
<p>If you want to use further CQL statements e.g. in your application later on you can always consult an up to date CQL documentation at: <a class="reference external" href="http://docs.datastax.com/en/cql/3.1/cql/cql_intro_c.html">http://docs.datastax.com/en/cql/3.1/cql/cql_intro_c.html</a></p>
<section id="keyspaces">
<h4>Keyspaces<a class="headerlink" href="#keyspaces" title="Permalink to this headline">¶</a></h4>
<p>Keyspaces are analogous to databases as you know it from classic relational database engines.</p>
<p>Lets create one, named <em>firstiot</em>. In the cqlsh type: <code class="docutils literal notranslate"><span class="pre">SOURCE</span> <span class="pre">'create_keyspace.cql'</span></code> and hit enter.</p>
<p>This will create a keyspace with the replication factor 2. The replication factor you define for a keyspace should never exceed the amount of nodes you run in a cluster. We use a SimpleStrategy for replication which is sufficient for a single <em>datacenter</em>. Study the script ‘<em>create_keyspace.cql</em>’.</p>
</section>
<section id="table-creation">
<h4>Table creation<a class="headerlink" href="#table-creation" title="Permalink to this headline">¶</a></h4>
<p>To create our first table in the keyspace “firstiot” you can run the script by typing the following in the cqlsh: <code class="docutils literal notranslate"><span class="pre">SOURCE</span> <span class="pre">'create_table.cql'</span></code></p>
<p>Study the script ‘<em>create_table.cql</em>’.</p>
<p>To work on the keyspace <em>firstiot</em> type: <code class="docutils literal notranslate"><span class="pre">USE</span> <span class="pre">firstiot;</span></code></p>
<p>Let’s see if our table has been created as expected:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>DESCRIBE TABLES<span class="p">;</span>
DESCRIBE TABLE sen_logging<span class="p">;</span>
</pre></div>
</div>
</section>
<section id="inserting-data">
<h4>Inserting data<a class="headerlink" href="#inserting-data" title="Permalink to this headline">¶</a></h4>
<p>To create our first dataset in our table <em>sen_logging</em> you can run the script by typing the following in the cqlsh: <code class="docutils literal notranslate"><span class="pre">SOURCE</span> <span class="pre">'insert_data.cql'</span></code></p>
<p>Study the script ‘<em>insert_data.cql</em>’.</p>
<p>Unfortunately our version of the cqlsh does not support UTF-8 characters with a width of more than one byte, when passing queries via a cql file. As you can see, we are able to smash this bug by the use of the function <code class="docutils literal notranslate"><span class="pre">blobAsText()</span></code> and pass a binary representation of the UTF-8 text string we want to insert into the specific varchar column.</p>
<p>To check if our data record was inserted correctly, we can perform a select statement on our table:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>USE firstiot<span class="p">;</span>
SELECT * from sen_logging<span class="p">;</span>
</pre></div>
</div>
</section>
<section id="deleting-data">
<h4>Deleting data<a class="headerlink" href="#deleting-data" title="Permalink to this headline">¶</a></h4>
<p>To delete the previously inserted data record you can invoke the following commands in the cqlsh:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>USE firstiot<span class="p">;</span>
DELETE from sen_logging WHERE <span class="nv">client_id</span> <span class="o">=</span> <span class="s1">&#39;&lt;client_id&gt;&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>Check if the table is blank again:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>SELECT * from sen_logging<span class="p">;</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="store-the-data-provided-by-the-raspberry-pi-s">
<h2>Store the data provided by the Raspberry Pi’s<a class="headerlink" href="#store-the-data-provided-by-the-raspberry-pi-s" title="Permalink to this headline">¶</a></h2>
<p>In this section we are going to modify the the well known application from the previous lab (MQTT) to publish data via a broker to an apache storm application, where the data is being written down to our cassandra cluster.</p>
<section id="provide-data-from-the-raspberry-pi">
<h3>Provide data from the Raspberry Pi<a class="headerlink" href="#provide-data-from-the-raspberry-pi" title="Permalink to this headline">¶</a></h3>
<p>To generate some data that can be written down to our Cassandra cluster, let’s add a RandomSpammer class which does excatly this task.</p>
<p>Download the <em>MQTT_thing-rg-0.2-dbg.zip</em> and study the code. The thread of this class should generate any data and publish it to a broker, just the way the TimeResource did in lab 3.</p>
<p>The data should be published as message in SenML. To check if the random generator works correctly launch the application on your Raspberry Pi and subscribe to the given topic with a console tool, e.g.:</p>
<p><code class="docutils literal notranslate"><span class="pre">mosquitto_sub</span> <span class="pre">-h</span> <span class="pre">172.16.32.5</span> <span class="pre">-t</span> <span class="pre">iot/labs/04/randomspammer</span> <span class="pre">-v</span></code></p>
<p>You may have noticed that all Raspberry Pis publish to the same topic. To distinguish which device published a message the hardware address is published within the payload too (key: <em>bn</em>). Be sure, the hardware address of your Raspberry Pi appears in the subscribed messages.</p>
</section>
<section id="sensor-markup-language-senml">
<h3>Sensor Markup Language – SenML<a class="headerlink" href="#sensor-markup-language-senml" title="Permalink to this headline">¶</a></h3>
<p>In short, the sensor markup language specifies, how recorded data from a sensor can be structured. The whole specification is available at: <a class="reference external" href="https://tools.ietf.org/html/draft-jennings-core-senml-02">https://tools.ietf.org/html/draft-jennings-core-senml-02</a></p>
<p>To format the messages we use the JSON representation of SenML. The base object variables have the following structure:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>+------------+------+--------+
<span class="p">|</span>      SenML <span class="p">|</span> JSON <span class="p">|</span> Type   <span class="p">|</span>
+------------+------+--------+
<span class="p">|</span>  Base Name <span class="p">|</span> bn   <span class="p">|</span> String <span class="p">|</span>
<span class="p">|</span>  Base Time <span class="p">|</span> bt   <span class="p">|</span> Number <span class="p">|</span>
<span class="p">|</span> Base Units <span class="p">|</span> bu   <span class="p">|</span> Number <span class="p">|</span>
<span class="p">|</span>    Version <span class="p">|</span> ver  <span class="p">|</span> Number <span class="p">|</span>
+------------+------+--------+
</pre></div>
</div>
<p>Further on there are measurement or parameter entries which represent as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>  +---------------+------+----------------+
  <span class="p">|</span>         SenML <span class="p">|</span> JSON <span class="p">|</span> Notes          <span class="p">|</span>
  +---------------+------+----------------+
  <span class="p">|</span>          Name <span class="p">|</span> n    <span class="p">|</span> String         <span class="p">|</span>
  <span class="p">|</span>         Units <span class="p">|</span> u    <span class="p">|</span> String         <span class="p">|</span>
  <span class="p">|</span>         Value <span class="p">|</span> v    <span class="p">|</span> Floating point <span class="p">|</span>
  <span class="p">|</span>  String Value <span class="p">|</span> sv   <span class="p">|</span> String         <span class="p">|</span>
  <span class="p">|</span> Boolean Value <span class="p">|</span> bv   <span class="p">|</span> Boolean        <span class="p">|</span>
  <span class="p">|</span>     Value Sum <span class="p">|</span> s    <span class="p">|</span> Floating point <span class="p">|</span>
  <span class="p">|</span>          Time <span class="p">|</span> t    <span class="p">|</span> Number         <span class="p">|</span>
  <span class="p">|</span>   Update Time <span class="p">|</span> ut   <span class="p">|</span> Number         <span class="p">|</span>
  +---------------+------+----------------+
</pre></div>
</div>
<p>An example about how the random data could be formatted:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
   <span class="s2">&quot;bn&quot;</span><span class="p">:</span> <span class="s2">&quot;b8:27:eb:f5:bf:53&quot;</span><span class="p">,</span>
   <span class="s2">&quot;e&quot;</span><span class="p">:</span> <span class="p">[{</span><span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="s2">&quot;1477672722000&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="s2">&quot;iot/labs/04/randomspammer&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
          <span class="s2">&quot;sv&quot;</span><span class="p">:</span> <span class="s2">&quot;520&quot;</span><span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To deal with JSON, we use the json module which comes with the defalut libraries of a python interpreter installation.</p>
<p>A basic Code snippet from the json module, which creates a json structure like the pictured above:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Mapping Python/JSON &quot;Types&quot;</span>
<span class="sd">    </span>
<span class="sd">    JSON              Python</span>
<span class="sd">    ============================</span>
<span class="sd">    object            dict</span>
<span class="sd">    array             list</span>
<span class="sd">    string            str</span>
<span class="sd">    number (int)      int</span>
<span class="sd">    number (real)     float</span>
<span class="sd">    true              True</span>
<span class="sd">    false             False</span>
<span class="sd">    null              None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">random_data</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">sensor_list</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
    <span class="n">measurement</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
    
    <span class="n">random_data</span><span class="p">[</span> <span class="s1">&#39;sv&#39;</span> <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">random_data</span><span class="p">[</span> <span class="s1">&#39;t&#39;</span> <span class="p">]</span>  <span class="o">=</span> <span class="n">timestamp</span>
    <span class="n">random_data</span><span class="p">[</span> <span class="s1">&#39;u&#39;</span> <span class="p">]</span>  <span class="o">=</span> <span class="n">unit</span>
    <span class="n">random_data</span><span class="p">[</span> <span class="s1">&#39;n&#39;</span> <span class="p">]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pub_topic</span>

    <span class="n">sensor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">random_data</span> <span class="p">)</span>

    <span class="n">measurement</span><span class="p">[</span> <span class="s1">&#39;e&#39;</span> <span class="p">]</span>  <span class="o">=</span> <span class="n">sensor_list</span>
    <span class="n">measurement</span><span class="p">[</span> <span class="s1">&#39;bn&#39;</span> <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_id</span>

    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span> <span class="n">measurement</span><span class="p">,</span> <span class="n">sort_keys</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">)</span>

</pre></div>
</div>
</section>
<section id="process-received-data-with-apache-storm">
<h3>Process received data with Apache Storm<a class="headerlink" href="#process-received-data-with-apache-storm" title="Permalink to this headline">¶</a></h3>
<p>Apache Storm is a free and open source distributed realtime computation system. Storm makes it easy to reliably process unbounded streams of data, doing for realtime processing. Storm is simple, can be used with any programming language, and is a lot of fun to use!</p>
<p>Source: <a class="reference external" href="http://storm.apache.org/">http://storm.apache.org/</a></p>
<p>In this last section of the lab, we do have a quick look at the Apache Storm framework. We use it to write the data published by the Raspberry Pi’s to our previously set up Cassandra cluster.</p>
<section id="id2">
<h4>Architecture Overview<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>On the <em>iot-lab-vsrvr</em> there is a version of the JDK and eclipse installed (icon on the desktop). Open it and choose the pre-selected workspace. Study the application <em>iot_lab4_mqtt-storm</em>. It’s implemented like pictured above. We assume, our Randomspammer delivers temperature data in different units (°C, °F, °K).</p>
<p>Therefore we set up 1 temperature <strong>spout</strong>, which has 4 <strong>bolts</strong> available to process data. How the bolts are chained to achieve the workflow pictured above is visible in the class TemperaturSpout. You have also the possibility to define multiple worker threads for each bolt, e.g. if you expect much more temperature data whose temperature unit is °K.</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="p">.</span><span class="na">setBolt</span><span class="p">(</span> <span class="s">&quot;temperatureKelvinBolt&quot;</span><span class="p">,</span> 
                 <span class="k">new</span> <span class="n">TemperatureKelvinBolt</span><span class="p">(),</span> <span class="mi">1</span> <span class="p">)</span>
               <span class="p">.</span><span class="na">shuffleGrouping</span><span class="p">(</span> <span class="s">&quot;temperature&quot;</span> <span class="p">);</span>
</pre></div>
</div>
<p>In our sample application we use 1 worker thread for each bolt, which is sufficient for this topic. You can now start the application <em>iot_lab4_mqtt-storm</em>: Right click on the MQTTTopology class &gt; Run As &gt; 2 Java Application. If you want just your own random messages change the topic name to an individual name, other than “iot/labs/04/randomspammer”.</p>
<p>Deploy the sample RandomSpammer (<em>MQTT_thing-rg-0.2-dbg.zip</em>) project to your Raspberry Pi and start it. If you want just your own random messages change the topic name to an individual name, other than <em>iot/labs/04/randomspammer</em>.</p>
<p>We have now a running environment with the following components:</p>
<ul class="simple">
<li><p>Cassandra database cluster on cassandra-node-0 and cassandra-node-1</p></li>
<li><p>At least 1 Raspberry Pi which acts as random data publisher</p></li>
<li><p>MQTT broker</p></li>
<li><p>Apache Storm powered application which acts as subscriber and writes the published data to our keyspace <em>firstiot</em> into the table <em>sen_logging</em>.</p></li>
</ul>
<p>To check if the random sensor data from the Raspberry Pi RandomSpammer are written correctly to the Cassandra cluster open a cqlsh on the machine <em>iot-lab-vsrvr</em> and run some select statements against the database, e.g.:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./cqlsh -C <span class="m">192</span>.168.122.10 <span class="m">9042</span>
SELECT * FROM firstiot.sen_logging<span class="p">;</span>
</pre></div>
</div>
<p>If you still have time and energy, customize the applications and try to log data from components of your choice that you have attached to your grovePi board.</p>
</section>
</section>
</section>
<section id="grading">
<h2>Grading<a class="headerlink" href="#grading" title="Permalink to this headline">¶</a></h2>
<p>3 points maximum will be awarded for completion of the exercises.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">IoT Labs</h1>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../lab_01/README.html">01 - Setup Laboratory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab_02/README.html">02 - CoAP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lab_03/README.html">03 - MQTT</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">04 - Cassandra</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#environment-overview">Environment overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternate-environment-setup">Alternate environment setup</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-the-guest-machine-iot-lab-vsrvr">Setting up the guest machine “iot-lab-vsrvr”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#apache-cassandra">Apache Cassandra</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#architecture-overview">Architecture Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#snitches">Snitches</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#get-in-touch-with-the-cqlsh-and-cql">Get in touch with the cqlsh and CQL</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#keyspaces">Keyspaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#table-creation">Table creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inserting-data">Inserting data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deleting-data">Deleting data</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#store-the-data-provided-by-the-raspberry-pi-s">Store the data provided by the Raspberry Pi’s</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#provide-data-from-the-raspberry-pi">Provide data from the Raspberry Pi</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sensor-markup-language-senml">Sensor Markup Language – SenML</a></li>
<li class="toctree-l3"><a class="reference internal" href="#process-received-data-with-apache-storm">Process received data with Apache Storm</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">Architecture Overview</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#grading">Grading</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../lab_03/README.html" title="previous chapter">03 - MQTT</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, stsh.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/lab_04/README.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>